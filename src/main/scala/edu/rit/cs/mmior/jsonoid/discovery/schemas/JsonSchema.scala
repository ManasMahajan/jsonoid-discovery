package edu.rit.cs.mmior.jsonoid.discovery
package schemas

import scala.reflect._
import scala.reflect.ClassTag

import org.json4s.JsonDSL._
import org.json4s._

import edu.rit.cs.mmior.jsonoid.BuildInfo

trait JsonSchema[T] {
  def toJson: JObject = {
    val propertyJson =
      properties.map(_.toJson).foldLeft(staticProperties)(_.merge(_))
    if (hasType) {
      ("type" -> schemaType) ~ propertyJson
    } else {
      propertyJson
    }
  }

  def toJsonSchema: JObject = {
    val schemaObj: JObject =
      ("$schema" -> "https://json-schema.org/draft/2019-09/schema") ~
        ("description" ->
          (s"""Generated by JSONoid ${BuildInfo.version}. Not to be""" +
            " used for validation purposes. See" +
            " https://github.com/michaelmior/jsonoid-discovery/."))

    toJson.merge(schemaObj)
  }

  def staticProperties: JObject = Nil

  def properties: SchemaProperties[T]

  def schemaType: String

  def hasType: Boolean = true

  def validTypes: Set[ClassTag[_ <: JValue]]

  @SuppressWarnings(Array("org.wartremover.warts.Equals"))
  def isValidType[S <: JValue](value: S)(implicit tag: ClassTag[S]): Boolean = {
    validTypes.contains(tag)
  }

  def mergeSameType()(implicit
      er: EquivalenceRelation
  ): PartialFunction[JsonSchema[_], JsonSchema[_]]

  def createProduct()(implicit
      er: EquivalenceRelation
  ): PartialFunction[JsonSchema[_], JsonSchema[_]] = { case other =>
    ProductSchema(this)(er).merge(other)
  }

  @SuppressWarnings(Array("org.wartremover.warts.NonUnitStatements"))
  def merge(
      other: JsonSchema[_]
  )(implicit er: EquivalenceRelation): JsonSchema[_] = {
    val sameType = mergeSameType()(er)
    if (sameType.isDefinedAt(other) && er.fuse(this, other)) {
      sameType(other)
    } else {
      createProduct()(er)(other)
    }
  }

  def copy(properties: SchemaProperties[T]): JsonSchema[_]

  def transformProperties(
      transformer: PartialFunction[JsonSchema[_], JsonSchema[_]]
  ): JsonSchema[_] = {
    copy(properties.transform(transformer))
  }

  def findByPointer(pointer: String): Option[JsonSchema[_]] = None

  def replaceWithReference(pointer: String, reference: String): JsonSchema[_] =
    this

  def isAnomalous(value: JValue, path: String = "$"): Boolean =
    !collectAnomalies(value, path).isEmpty

  def collectAnomalies[S <: JValue](
      value: S,
      path: String = "$"
  )(implicit tag: ClassTag[S]): Seq[Anomaly] = {
    if (isValidType(value)(tag)) {
      properties.flatMap(_.collectAnomalies(value, path)).toSeq
    } else {
      Seq(Anomaly(path, f"${value} has wrong type", Fatal))
    }
  }
}
